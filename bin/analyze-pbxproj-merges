#!/bin/sh

# current_branch() function nabbed from ohmyzsh git plugin
current_branch() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || \
  ref=$(git rev-parse --short HEAD 2> /dev/null) || return
  echo ${ref#refs/heads/}
}

use_colors() {
    # TODO: check whether output is connected to a TTY
    echo 1
}

_echo_with_color_code() {
    color_code=$1
    text="$2"
    if [ $(use_colors) = 1 ]; then
        printf "\e[%sm%s\e[0m\n" $color_code "${text}"
    else
        echo "$text"
    fi
}

echo_green() {
    _echo_with_color_code 32 "$1"
}

echo_red() {
    _echo_with_color_code 31 "$1"
}

echo_amber() {
    _echo_with_color_code 33 "$1"
}

echo_bold() {
    _echo_with_color_code "0;1" "$1"
}

temp_branch_prefix=$(basename $0)
original_head_ref=$(current_branch)

# Set the merge=union attribute on .pbxproj files
# TODO: Move any existing attributes file aside, move back into place at end 
# of run
echo "*.pbxproj merge=union" >> ".git/info/attributes"

# Start by finding all merges where there was a project.pbxproj conflict. Just 
# list the SHA hashes. For now we're not going to include "octopus" merges 
# (merges where there are more than two parents).
# 
# This grep stuff is a bit ropey. We're assuming that if the commit log 
# includes the phrases "Conflicts:" and "project.pbkproj" then there was a
# merge conflict in that file. This isn't necessarily the case, but it'll do
# for now.
for sha in $(git log --min-parents=2 --max-parents=2 --format=%h --grep "Conflicts:" --grep "project.pbxproj" --all-match); do
    subject=$(git log --max-count 1 --format=%s $sha)
    echo_bold "Analyzing $sha ($subject)"
    
    # For now, we're only interested in commits where the .pbxproj file was
    # the only conflict. That means we expect to find 3 lines in the commit 
    # body: "Conficts:", the path to the .pbxproj, and an empty line
    body_lines=$(git log --max-count 1 --format=%b $sha | wc -l)
    number_of_conflicts=$(echo $body_lines-2 | bc)
    if [ $number_of_conflicts != 1 ]; then
        echo "  Merge contains more than one conflicting file - skipping"
        echo
        continue
    fi

    # Get the parent 
    parent_shas=$(git log --pretty=%p --max-count 1 $sha)
    first_parent_sha=$(echo $parent_shas | cut -f1 -d' ')
    other_parent_shas=$(echo $parent_shas | cut -f2- -d' ')

    temp_branch="$temp_branch_prefix/$sha"
    
    # Check out the first parent
    echo "  Checking out temporary branch $temp_branch"
    git checkout -b $temp_branch $first_parent_sha > /dev/null 2>&1

    git merge --no-edit "$other_parent_shas" > /dev/null 2>&1
    if [ $? = 0 ]; then
        echo "  Merge worked OK with merge=union attribute set"
        
        # Do a quiet diff, which exits 0 on no output, 1 otherwise, 
        # then show diff output only if there's anything to show
        git diff --quiet $sha
        if [ $? = 0 ]; then
            echo_green "  No diffs when compared with original merge"
        else
            diff_stat=$(git diff --shortstat $sha)
            echo_amber "  Diffs when compared with original merge: $diff_stat"

            # Show the diffs for user to inspect
            #git diff $sha
        fi
    else
        echo_red "  Merge still failed, even with merge=union attribute set"
        git merge --abort > /dev/null 2>&1
    fi

    # Clean up
    git reset HEAD . > /dev/null 2>&1
    git checkout $original_head_ref > /dev/null 2>&1

    echo "  Deleting temporary branch $temp_branch"
    git branch -D $temp_branch > /dev/null 2>&1

    echo
done
